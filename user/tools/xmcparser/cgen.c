/*
 * $FILE: cgen.c
 *
 * Dumps the information in C format
 *
 * $VERSION$
 *
 * $AUTHOR$
 *
 * $LICENSE:
 * COPYRIGHT (c) Fent Innovative Software Solutions S.L.
 *     Read LICENSE.txt file for the license terms.
 */

#include <xm_inc/linkage.h>
#include <stdio.h>
#include <xm_inc/arch/paging.h>
#include <xm_inc/arch/asm_offsets.h>
#include <xm_inc/guest.h>
#include "common.h"
#include "xmc.h"

#define XMC_C_HEADER "/* File generated by xmcparser. Don't modify. */\n\n" \
                     "#include <xm_inc/xmconf.h>\n\n"

#define PRINT_PREF

static inline void GenerateHm(FILE *oFile, struct xmcHmSlot *hmTab) {
    extern char *hmActions[];
    extern char *hmEvents[];
    extern char *hmLog[];
    int i;
    fprintf(oFile, ADDNTAB(1, ".hmTab = {\n"));
    for (i=0; i<XM_HM_MAX_EVENTS; i++)
        if (hmEvents[i])
            fprintf(oFile, ADDNTAB(2, "[%s] = {.action = %s, .log = %s },\n"), hmEvents[i], hmActions[hmTab[i].action], hmLog[hmTab[i].log]);
    
    fprintf(oFile, ADDNTAB(1, "},\n"));
}

static inline void GenerateRegionTab(FILE *oFile) {
    int e;
    fprintf(oFile, "const struct xmcMemoryRegion xmcMemRegTab[] = {\n");
    
    for (e=0; e<xmc.noRegions; e++) {
		fprintf(oFile, 
			ADDNTAB(1, "[%d] = {\n")
			ADDNTAB(2, ".startAddr = 0x%"PRINT_PREF"x,\n")
			ADDNTAB(2, ".size = %"PRINT_PREF"u,\n")
			ADDNTAB(2, ".flags = 0x%x,\n")
			ADDNTAB(1, "},\n"),
			e, xmcMemRegTab[e].startAddr, xmcMemRegTab[e].size, xmcMemRegTab[e].flags);
    }
    
    fprintf(oFile, "};\n\n");
}

static inline void GeneratePhysMemAreaTab(FILE *oFile) {
    int i;
    fprintf(oFile, "const struct xmcMemoryArea xmcPhysMemAreaTab[] = {\n");
    for (i=0; i<xmc.noPhysicalMemoryAreas; i++) {
	fprintf(oFile, ADDNTAB(1, "[%d] = {\n"), i);
        fprintf(oFile, ADDNTAB(2, ".nameOffset = %u,\n"),  xmcMemAreaTab[i].nameOffset);
	fprintf(oFile, ADDNTAB(2, ".startAddr = 0x%"PRINT_PREF"x,\n"),  xmcMemAreaTab[i].startAddr);
        fprintf(oFile, ADDNTAB(2, ".mappedAt = 0x%"PRINT_PREF"x,\n"),  xmcMemAreaTab[i].mappedAt);
	fprintf(oFile, ADDNTAB(2, ".size = %"PRINT_PREF"u,\n"), xmcMemAreaTab[i].size);
	fprintf(oFile, ADDNTAB(2, ".flags = 0x%x,\n"), xmcMemAreaTab[i].flags);
        fprintf(oFile, ADDNTAB(2, ".memoryRegionOffset = 0x%x,\n"), xmcMemAreaTab[i].memoryRegionOffset);
	fprintf(oFile, ADDNTAB(1, "},\n"));
    }
    fprintf(oFile, "};\n\n");
}

#ifdef CONFIG_CYCLIC_SCHED
static inline void GenerateCyclicSlots(FILE *oFile) {
    int j;
    fprintf(oFile, "const struct xmcSchedCyclicSlot xmcSchedCyclicSlotTab[] = {\n");
    for(j=0; j<xmc.noSchedCyclicSlots; j++) {
	fprintf(oFile,
		ADDNTAB(1, "[%d] = {\n")
		ADDNTAB(2, ".id = 0x%x,\n")
		ADDNTAB(2, ".partitionId = %d,\n")
                ADDNTAB(2, ".vCpuId = %d,\n")
		ADDNTAB(2, ".sExec = %d,\n")
		ADDNTAB(2, ".eExec = %d,\n")
		ADDNTAB(1, "},\n"),
                j, xmcSchedCyclicSlotTab[j].id, xmcSchedCyclicSlotTab[j].partitionId, xmcSchedCyclicSlotTab[j].vCpuId, xmcSchedCyclicSlotTab[j].sExec, xmcSchedCyclicSlotTab[j].eExec);
    }	
    fprintf(oFile, "};\n\n");
    
}

static inline void GenerateCyclicPlans(FILE *oFile) {
    int j;
    fprintf(oFile, "const struct xmcSchedCyclicPlan xmcSchedCyclicPlanTab[] = {\n");
    for(j=0; j<xmc.noSchedCyclicPlans; j++) {
	fprintf(oFile,
		ADDNTAB(1, "[%d] = {\n")
                ADDNTAB(2, ".nameOffset = %d,\n")
		ADDNTAB(2, ".id = 0x%x,\n")
		ADDNTAB(2, ".majorFrame = %u,\n")
#ifdef CONFIG_PLAN_EXTSYNC
                ADDNTAB(2, ".extSync = %d,\n")
#endif
		ADDNTAB(2, ".noSlots = %d,\n")
		ADDNTAB(2, ".slotsOffset = %d,\n")
		ADDNTAB(1, "},\n"),
		j, xmcSchedCyclicPlanTab[j].nameOffset, xmcSchedCyclicPlanTab[j].id, xmcSchedCyclicPlanTab[j].majorFrame,
#ifdef CONFIG_PLAN_EXTSYNC
                xmcSchedCyclicPlanTab[j].extSync,
#endif
                xmcSchedCyclicPlanTab[j].noSlots, xmcSchedCyclicPlanTab[j].slotsOffset);
    }	
    fprintf(oFile, "};\n\n");
    
}
#endif

static inline void GenerateDev(FILE *oFile, char name[], xmDev_t *dev) {
    fprintf(oFile, ADDNTAB(1, ".%s = { .id= 0x%x, .subId = 0x%x,},\n"), name, dev->id, dev->subId);
}

static inline void GenerateTrace(FILE *oFile, struct xmcTrace *trace) {
    fprintf(oFile, ADDNTAB(1, ".trace = {\n"));
    GenerateDev(oFile, "dev", &trace->dev);
    fprintf(oFile, ADDNTAB(2, ".bitmap = 0x%x,\n"), trace->bitmap);
    fprintf(oFile, ADDNTAB(1, "},\n"));
}

static inline void GenerateCommChannelTab(FILE *oFile) {
    int e;
    fprintf(oFile, "const struct xmcCommChannel xmcCommChannelTab[] = {\n");
    
    for (e=0; e<xmc.noCommChannels; e++) {
	fprintf(oFile,
		ADDNTAB(1, "[%d] = {\n")
		ADDNTAB(2, ".type = "),	e);
	
	switch(xmcCommChannelTab[e].type) {
	case XM_SAMPLING_CHANNEL:
	    fprintf(oFile,
		    "XM_SAMPLING_CHANNEL,\n"
		    ADDNTAB(2, "{.s.maxLength = %d,\n")
		    ADDNTAB(2, ".s.validPeriod = %u,\n")
                    ADDNTAB(2, ".s.noReceivers = %d, },\n"),
		    xmcCommChannelTab[e].s.maxLength,
		    xmcCommChannelTab[e].s.validPeriod,
                    xmcCommChannelTab[e].s.noReceivers
                );
	    break;
	case XM_QUEUING_CHANNEL:
	    fprintf(oFile,
		    "XM_QUEUING_CHANNEL,\n"
		    ADDNTAB(2, "{.q.maxLength = %d,\n")
		    ADDNTAB(2, ".q.maxNoMsgs = %d, },\n"),
		    xmcCommChannelTab[e].q.maxLength, xmcCommChannelTab[e].q.maxNoMsgs);
	    break;
#if defined(CONFIG_DEV_TTNOC)||defined(CONFIG_DEV_TTNOC_MODULE)
	case XM_TTNOC_CHANNEL:
	    fprintf(oFile,
		    "XM_TTNOC_CHANNEL,\n"
		    ADDNTAB(2, "{.t.maxLength = %d,\n")
		    ADDNTAB(2, ".t.validPeriod = %u,\n")
		    ADDNTAB(2, ".t.noReceivers = %d,\n")
                    ADDNTAB(2, ".t.nodeId = %d, },\n"),
		    xmcCommChannelTab[e].t.maxLength,
		    xmcCommChannelTab[e].t.validPeriod,
		    xmcCommChannelTab[e].t.noReceivers,
                    xmcCommChannelTab[e].t.nodeId
                );
             break;
#endif
	}
	
	fprintf(oFile, ADDNTAB(1, "},\n"));
    }
    
    fprintf(oFile, "};\n\n");
}

static inline void GenerateCommPortTab(FILE *oFile) {
    int e;
    fprintf(oFile, "const struct xmcCommPort xmcCommPorts[] = {\n");
    for (e=0; e<xmc.noCommPorts; e++) {
	fprintf(oFile,
	    	ADDNTAB(1, "[%d] = {\n")
	    	ADDNTAB(2, ".nameOffset = %d,\n")
		ADDNTAB(2, ".channelId = "),
		e, xmcCommPortTab[e].nameOffset);
	
	if (xmcCommPortTab[e].channelId==XM_NULL_CHANNEL) {
	    fprintf(oFile, "XM_NULL_CHANNEL, \n");
	} else {
	    fprintf(oFile,
		    "%d, \n", xmcCommPortTab[e].channelId);
	}
	
	fprintf(oFile, ADDNTAB(2, ".direction = "));
	
	switch(xmcCommPortTab[e].direction) {
	case XM_SOURCE_PORT:
	    fprintf(oFile, "XM_SOURCE_PORT, \n");
	    break;
	case XM_DESTINATION_PORT:
	    fprintf(oFile, "XM_DESTINATION_PORT, \n");
	    break;
	}
	
	fprintf(oFile, ADDNTAB(2, ".type = "));
	switch(xmcCommPortTab[e].type) {
	case XM_SAMPLING_PORT:
	    fprintf(oFile, "XM_SAMPLING_PORT, \n");
	    break;
	case XM_QUEUING_PORT:
	    fprintf(oFile, "XM_QUEUING_PORT, \n");
	    break;
#if defined(CONFIG_DEV_TTNOC)||defined(CONFIG_DEV_TTNOC_MODULE)
	case XM_TTNOC_PORT:
	    fprintf(oFile, "XM_TTNOC_PORT, \n");
	    break;
#endif
	}
#if defined(CONFIG_DEV_TTNOC)||defined(CONFIG_DEV_TTNOC_MODULE)
	fprintf(oFile, ADDNTAB(2, ".devId = {"));
	fprintf(oFile,
	    	ADDNTAB(1, ".id = 0x%x, .subId = 0x%x,}\n"),
		xmcCommPortTab[e].devId.id, xmcCommPortTab[e].devId.subId);
#endif

	fprintf(oFile, ADDNTAB(1, "},\n"));

//.id= 0x0, .subId = 0x0,},

    }
    fprintf(oFile, "};\n\n");
}

static inline void GenerateIpviTab(FILE *oFile) {
    int e;
    fprintf(oFile, "const xm_u8_t xmcIpviDstTab[] = { ");
    for (e=0; e<xmc.noIpviDsts; e++)
        fprintf(oFile, "%d, ", ipviDstTab[e]);
    fprintf(oFile, "};\n\n");
}

static inline void GenerateHpv(FILE *oFile) {
    int e;
    fprintf(oFile, ADDNTAB(1, ".hpv = {\n"));
    fprintf(oFile, ADDNTAB(2, ".noPhysicalMemoryAreas = %d,\n"), xmc.hpv.noPhysicalMemoryAreas);    
    fprintf(oFile, ADDNTAB(2, ".physicalMemoryAreasOffset = %d,\n"), xmc.hpv.physicalMemoryAreasOffset);
    fprintf(oFile, ADDNTAB(2, ".noCpus = %d,\n")
	    ADDNTAB(2, ".cpuTab = {\n"), xmc.hpv.noCpus);
    
    for (e=0; e<xmc.hpv.noCpus; e++) {
        fprintf(oFile,
                ADDNTAB(3, "[%d] = {\n")
                ADDNTAB(4, ".id = %d,\n")
                ADDNTAB(4, ".features = 0x%x,\n")
                ADDNTAB(4, ".freq = "), e, xmc.hpv.cpuTab[e].id, xmc.hpv.cpuTab[e].features);
        
        if (!xmc.hpv.cpuTab[e].freq)
            fprintf(oFile, "XM_CPUFREQ_AUTO,\n");
        else
            fprintf(oFile, "%u,\n",xmc.hpv.cpuTab[e].freq);
#ifdef CONFIG_CYCLIC_SCHED
        fprintf(oFile, ADDNTAB(4, ".schedCyclicPlansOffset = %d,\n")
                ADDNTAB(4, ".noSchedCyclicPlans = %d,\n"),
                xmc.hpv.cpuTab[e].schedCyclicPlansOffset,
                xmc.hpv.cpuTab[e].noSchedCyclicPlans
            );
#endif
#ifdef CONFIG_FP_SCHED
        fprintf(oFile, ADDNTAB(4, ".schedFpTabOffset = %d,\n")
                ADDNTAB(4, ".noFpEntries = %d,\n"),
                xmc.hpv.cpuTab[e].schedFpTabOffset,
                xmc.hpv.cpuTab[e].noFpEntries
            );
#endif

        fprintf(oFile, ADDNTAB(4, ".schedPolicy = %d,\n"), xmc.hpv.cpuTab[e].schedPolicy);
	fprintf(oFile, ADDNTAB(3, "},\n"));
    }    

    fprintf(oFile,
	    ADDNTAB(2, "},\n"));
    GenerateHm(oFile, xmc.hpv.hmTab);
    fprintf(oFile,
	    ADDNTAB(2, ".hwIrqTab = {\n"));
    
    for (e=0; e<CONFIG_NO_HWIRQS; e++) {
        fprintf(oFile, ADDNTAB(3, "[%d] = {.owner = "), e);
        
        if (xmc.hpv.hwIrqTab[e].owner==XM_IRQ_NO_OWNER)
            fprintf(oFile, "XM_IRQ_NO_OWNER, },\n");
        else
            fprintf(oFile, "%d, },\n", xmc.hpv.hwIrqTab[e].owner);
    }
    fprintf(oFile, ADDNTAB(2, "},\n"));
    GenerateTrace(oFile, &xmc.hpv.trace);
    GenerateDev(oFile, "consoleDev", &xmc.hpv.consoleDev);
    GenerateDev(oFile, "hmDev", &xmc.hpv.hmDev);
    fprintf(oFile, ADDNTAB(2, ".nodeId = %d,\n"),xmc.hpv.nodeId);
    fprintf(oFile, ADDNTAB(1, "},\n")); 
}

static inline void GenerateRsw(FILE *oFile) {
    fprintf(oFile, ADDNTAB(1, ".rsw = {\n"));
    fprintf(oFile, ADDNTAB(2, ".noPhysicalMemoryAreas = %d,\n"), xmc.rsw.noPhysicalMemoryAreas);
    fprintf(oFile, ADDNTAB(2, ".physicalMemoryAreasOffset = %d,\n"), xmc.rsw.physicalMemoryAreasOffset);
    fprintf(oFile, ADDNTAB(1, "},\n"));
}

static inline void GeneratePartitionTab(FILE *oFile) {
    int e, noVCpu, i;

    fprintf(oFile, "struct xmcBootPart xmcBootPartitionTab[%d];\n", xmc.noPartitions);

    fprintf(oFile, "const struct xmcPartition xmcPartitionTab[] = {\n");
    for (e=0, noVCpu=0; e<xmc.noPartitions; e++, noVCpu+=xmcPartitionTab[e].noVCpus) {
	fprintf(oFile,
		ADDNTAB(1, "[%d] = {\n")
		ADDNTAB(2, ".id = %d,\n")
		ADDNTAB(2, ".nameOffset = %d,\n")
		ADDNTAB(2, ".flags = 0x%x,\n"),
		e, xmcPartitionTab[e].id, xmcPartitionTab[e].nameOffset, xmcPartitionTab[e].flags);
        fprintf(oFile, ADDNTAB(2, ".noVCpus = %d,\n"), xmcPartitionTab[e].noVCpus);
        fprintf(oFile, ADDNTAB(2, ".hwIrqs = 0x%x,\n"), xmcPartitionTab[e].hwIrqs);
	GenerateDev(oFile, "consoleDev", &xmcPartitionTab[e].consoleDev);
	fprintf(oFile,
		ADDNTAB(2, ".noPhysicalMemoryAreas = %d,\n")
		ADDNTAB(2, ".physicalMemoryAreasOffset = %d,\n"),
		xmcPartitionTab[e].noPhysicalMemoryAreas, xmcPartitionTab[e].physicalMemoryAreasOffset);
	GenerateHm(oFile, xmcPartitionTab[e].hmTab);
	fprintf(oFile,
		ADDNTAB(2, ".noPorts = %d,\n")
		ADDNTAB(2, ".commPortsOffset = %d,\n"), xmcPartitionTab[e].noPorts,
		xmcPartitionTab[e].commPortsOffset);
        
	fprintf(oFile, ADDNTAB(2, ".ioPortsOffset = %d,\n"), xmcPartitionTab[e].ioPortsOffset);	
	fprintf(oFile, ADDNTAB(2, ".noIoPorts = %d,\n"), xmcPartitionTab[e].noIoPorts); 
	GenerateTrace(oFile, &xmcPartitionTab[e].trace);
        fprintf(oFile, ADDNTAB(2, ".ipviTab = {\n"));
        for (i=0; i<CONFIG_XM_MAX_IPVI; i++) {
            fprintf(oFile, ADDNTAB(3, "[%d] = {\n"), i);
            fprintf(oFile, ADDNTAB(4, ".dstOffset = %d,\n"), xmcPartitionTab[e].ipviTab[i].dstOffset);
            fprintf(oFile, ADDNTAB(4, ".noDsts = %d,\n"), xmcPartitionTab[e].ipviTab[i].noDsts);
            fprintf(oFile, ADDNTAB(3, "},\n"));
        }
        fprintf(oFile, ADDNTAB(2, "},\n"));
	fprintf(oFile, ADDNTAB(1, "},\n"));
    }
    fprintf(oFile, "};\n\n");
}

static inline void GenerateStringTab(FILE *oFile) {
    int i;
    /* String Table */
    fprintf(oFile, "const char xmcStringTab[] = {");
    for (i=0; i<xmc.stringTabLength; i++)
	fprintf(oFile, ADDNTAB(1, "0x%x, "), strTab[i]);
    fprintf(oFile, "};\n\n");
}

static inline void GenerateSystemDevices(FILE *oFile) {
#if defined(CONFIG_DEV_MEMBLOCK)||defined(CONFIG_DEV_MEMBLOCK_MODULE)
    int e;
    fprintf(oFile, "const struct xmcMemBlock xmcMemBlockTab[]={\n");
    
    for (e=0; e<xmc.deviceTab.noMemBlocks; e++) {
	fprintf(oFile, ADDNTAB(1, "[%d] = {\n"), e);
        fprintf(oFile, ADDNTAB(2, ".physicalMemoryAreasOffset = %d,\n"), xmcMemBlockTab[e].physicalMemoryAreasOffset);
	fprintf(oFile, ADDNTAB(1, "},\n"));
    }    
    fprintf(oFile, "};\n\n");
#endif   
#if defined(CONFIG_DEV_TTNOC)||defined(CONFIG_DEV_TTNOC_MODULE)
    int i;
    fprintf(oFile, "const struct xmcTTnocSlot xmcTTnocSlotTab[]={\n");
    
    for (i=0; i<xmc.deviceTab.noTTnocSlots; i++) {
	fprintf(oFile, ADDNTAB(1, "[%d] = {\n"), i);
        fprintf(oFile, ADDNTAB(2, ".ttsocId = 0x%"PRINT_PREF"x,\n"), xmcTTnocSlotTab[i].ttsocId);
        fprintf(oFile, ADDNTAB(2, ".size = %"PRINT_PREF"u,\n"), xmcTTnocSlotTab[i].size);
        fprintf(oFile, ADDNTAB(2, ".type = "));

        switch(xmcTTnocSlotTab[i].type) {
        case XM_SOURCE_PORT:
            fprintf(oFile, "XM_SOURCE_PORT, \n");
            break;
        case XM_DESTINATION_PORT:
            fprintf(oFile, "XM_DESTINATION_PORT, \n");
            break;
        }
        fprintf(oFile, ADDNTAB(2, ".nodeId = %d,\n"), xmcTTnocSlotTab[i].nodeId);
	fprintf(oFile, ADDNTAB(2, ".devId = {"));
	fprintf(oFile,
	    	ADDNTAB(1, ".id = 0x%x, .subId = 0x%x,}\n"),
		xmcTTnocSlotTab[i].devId.id, xmcTTnocSlotTab[i].devId.subId);

	fprintf(oFile, ADDNTAB(1, "},\n"));
    }    
    fprintf(oFile, "};\n\n");
#endif   
}

static inline void GenerateXMC(FILE *oFile) {
    int e;
    fprintf(oFile, "struct xmcRswInfo xmcRswInfo;\n\n");
    fprintf(oFile, "const struct xmc xmc __attribute__ ((section(\".rodata.hdr\"))) = {\n"
	    ADDNTAB(1, ".signature = XMC_SIGNATURE,\n")
            ADDNTAB(1, ".dataSize = (xmSize_t)_dataSize,\n")
            ADDNTAB(1, ".size = (xmSize_t)_xmcSize,\n")
	    ADDNTAB(1, ".version = XMC_SET_VERSION(%d, %d, %d),\n")
	    ADDNTAB(1, ".fileVersion = XMC_SET_VERSION(%d, %d, %d),\n")	    
	    ADDNTAB(1, ".rsvMemTabOffset = (xmAddress_t)_memObjTab,\n")
	    ADDNTAB(1, ".nameOffset = %"PRINT_PREF"d,\n"),
	    XMC_VERSION, XMC_SUBVERSION, XMC_REVISION, XMC_GET_VERSION(xmc.fileVersion), XMC_GET_SUBVERSION(xmc.fileVersion), XMC_GET_REVISION(xmc.fileVersion), xmc.nameOffset);
    GenerateHpv(oFile);
    GenerateRsw(oFile);
    fprintf(oFile, ADDNTAB(1, ".partitionTabOffset = (xmAddress_t)xmcPartitionTab,\n"));    
    fprintf(oFile,
	    ADDNTAB(1, ".noPartitions = %d,\n"), xmc.noPartitions);

    fprintf(oFile, ADDNTAB(1, ".bootPartitionTabOffset = (xmAddress_t)xmcBootPartitionTab,\n"));
    fprintf(oFile, ADDNTAB(1, ".rswInfoOffset = (xmAddress_t)&xmcRswInfo,\n"));
    fprintf(oFile,
	    ADDNTAB(1, ".memoryRegionsOffset = (xmAddress_t)xmcMemRegTab,\n")
	    ADDNTAB(1, ".noRegions = %d,\n"), xmc.noRegions);
    fprintf(oFile,
	    ADDNTAB(1, ".physicalMemoryAreasOffset = (xmAddress_t)xmcPhysMemAreaTab,\n")
	    ADDNTAB(1, ".noPhysicalMemoryAreas = %d,\n"), xmc.noPhysicalMemoryAreas);
#ifdef CONFIG_CYCLIC_SCHED
    fprintf(oFile, 
	    ADDNTAB(1, ".schedCyclicSlotsOffset = (xmAddress_t)xmcSchedCyclicSlotTab,\n")
	    ADDNTAB(1, ".noSchedCyclicSlots = %d,\n"), xmc.noSchedCyclicSlots);

    fprintf(oFile, 
	    ADDNTAB(1, ".schedCyclicPlansOffset = (xmAddress_t)xmcSchedCyclicPlanTab,\n")
	    ADDNTAB(1, ".noSchedCyclicPlans = %d,\n"), xmc.noSchedCyclicPlans);
#endif
    fprintf(oFile, 
	    ADDNTAB(1, ".commChannelTabOffset = (xmAddress_t)xmcCommChannelTab,\n")
	    ADDNTAB(1, ".noCommChannels = %d,\n"), xmc.noCommChannels);
    fprintf(oFile, 
	    ADDNTAB(1, ".commPortsOffset = (xmAddress_t)xmcCommPorts,\n")
	    ADDNTAB(1, ".noCommPorts = %d,\n"), xmc.noCommPorts);

    fprintf(oFile, 
	    ADDNTAB(1, ".ioPortsOffset = (xmAddress_t)xmcIoPortTab,\n")
	    ADDNTAB(1, ".noIoPorts = %d,\n"), xmc.noIoPorts);

    fprintf(oFile,
	    ADDNTAB(1, ".ipviDstOffset = (xmAddress_t)xmcIpviDstTab,\n")
	    ADDNTAB(1, ".noIpviDsts = %d,\n"), xmc.noIpviDsts);

#ifdef CONFIG_FP_SCHED
    fprintf(oFile,
	    ADDNTAB(1, ".fpSchedTabOffset = (xmAddress_t)xmcFpSchedTab,\n"));
    fprintf(oFile,
	    ADDNTAB(1, ".noFpEntries = %d,\n"), xmc.noFpEntries);
#endif    
    fprintf(oFile,
	    ADDNTAB(1, ".vCpuTabOffset = (xmAddress_t)&xmcVCpuTab[0][0],\n"));
    fprintf(oFile, 
	    ADDNTAB(1, ".stringsOffset = (xmAddress_t)xmcStringTab,\n")
	    ADDNTAB(1, ".stringTabLength = %d,\n"), xmc.stringTabLength);

    fprintf(oFile, ADDNTAB(1, ".deviceTab = {\n"));
#if defined(CONFIG_DEV_MEMBLOCK)||defined(CONFIG_DEV_MEMBLOCK_MODULE)
    fprintf(oFile, ADDNTAB(2, ".memBlocksOffset = (xmAddress_t)xmcMemBlockTab,\n"));
    fprintf(oFile, ADDNTAB(2, ".noMemBlocks = %d,\n"), xmc.deviceTab.noMemBlocks);
#endif
#if defined(CONFIG_DEV_TTNOC)||defined(CONFIG_DEV_TTNOC_MODULE)
    fprintf(oFile, ADDNTAB(2, ".ttnocSlotOffset = (xmAddress_t)xmcTTnocSlotTab,\n"));
    fprintf(oFile, ADDNTAB(2, ".noTTnocSlots = %d,\n"), xmc.deviceTab.noTTnocSlots);
#endif
#if defined(CONFIG_DEV_UART)||defined(CONFIG_DEV_UART_MODULE)
    fprintf(oFile, ADDNTAB(2, ".uart = {\n"));
    for (e=0; e<CONFIG_DEV_NO_UARTS; e++)
	
	fprintf(oFile, ADDNTAB(3, "[%d] = {.baudRate = %d, },\n"), e, xmc.deviceTab.uart[e].baudRate);
    fprintf(oFile, ADDNTAB(2, "},\n"));
#endif
    fprintf(oFile, ADDNTAB(1, "},\n"));
    fprintf(oFile, "};\n");
}

extern void ArchLdrRsvMem(FILE *oFile);

#ifdef CONFIG_MPU
extern void ArchMpuRsvMem(FILE *oFile);
#endif
#ifdef CONFIG_MMU
extern void ArchMmuRsvMem(FILE *oFile);
#endif

static void GenerateRsvMem(FILE *oFile) {
    int i, j, noVCpus;
    
#if defined(CONFIG_SMP)&&!defined(CONFIG_ARCH_MMU_BYPASS)
    for (i=1; i<CONFIG_NO_CPUS; i++) {
#ifndef CONFIG_x86
        RsvBlock(CTXTTABSIZE, CTXTTABSIZE, "ctxtTab");
#endif
        RsvBlock(PTDL1SIZE, PTDL1SIZE, "ptdL1Tab");
        RsvBlock(PTDL2SIZE, PTDL2SIZE, "ptdL2Tab");
#ifndef CONFIG_x86
        RsvBlock(PTDL3SIZE, PTDL3SIZE, "ptdL3Tab");
#endif
    }
#endif

    for (i=0, noVCpus=0; i<xmc.noPartitions; i++) {
        noVCpus+=xmcPartitionTab[i].noVCpus;
        RsvBlock(xmcPartitionTab[i].noVCpus*_KTHREADPTR_T_SIZEOF, ALIGNMENT, "partition's kthread table");
        for (j=0; j<xmcPartitionTab[i].noVCpus; j++) {
            RsvBlock(_KTHREAD_T_SIZEOF, ALIGNMENT, "kthread");
            RsvBlock(_STRUCT_GUEST_SIZEOF, ALIGNMENT, "vcpu");
        }
    } 

    // Partitions
    RsvBlock(xmc.noPartitions*_PARTITION_T_SIZEOF, ALIGNMENT, "scheduler's partitions table");
    
    for (i=0; i<xmc.noCommChannels; i++) {
        if (xmcCommChannelTab[i].type==XM_SAMPLING_CHANNEL){
            if (xmcCommChannelTab[i].s.noReceivers) {
                RsvBlock(xmcCommChannelTab[i].s.noReceivers*_KTHREADPTR_T_SIZEOF, ALIGNMENT, "Sampling channel's receivers");
                RsvBlock(xmcCommChannelTab[i].s.noReceivers*sizeof(xm_s32_t), ALIGNMENT, "Sampling channel's receiver ports");
            }
        }
#if defined(CONFIG_DEV_TTNOC)||defined(CONFIG_DEV_TTNOC_MODULE)
        if (xmcCommChannelTab[i].type==XM_TTNOC_CHANNEL){
            if (xmcCommChannelTab[i].t.noReceivers) {
                RsvBlock(xmcCommChannelTab[i].t.noReceivers*_KTHREADPTR_T_SIZEOF, ALIGNMENT, "TTNoC channel's receivers");
                RsvBlock(xmcCommChannelTab[i].t.noReceivers*sizeof(xm_s32_t), ALIGNMENT, "TTNoC channel's receiver ports");
            }
        }
#endif
    }

#ifdef CONFIG_MMU
    RsvBlock(xmc.noRegions*_STRUCT_PHYSPAGEPTR_SIZEOF, ALIGNMENT, "MMU region tables");
    for (i=0; i<xmc.noRegions; i++)
	if (xmcMemRegTab[i].flags&XMC_REG_FLAG_PGTAB)
	    RsvBlock((xmcMemRegTab[i].size/PAGE_SIZE)*_STRUCT_PHYSPAGE_SIZEOF, ALIGNMENT, "MMU region tables");

    ArchMmuRsvMem(oFile);
#endif
    for (i=0; i<xmc.noPartitions; i++) {
        RsvBlock(xmcPartitionTab[i].noVCpus*(sizeof(partitionControlTable_t)+sizeof(struct xmPhysicalMemMap)*xmcPartitionTab[i].noPhysicalMemoryAreas+((xmcPartitionTab[i].noPorts&((1<<XM_LOG2_WORD_SZ)-1))?(xmcPartitionTab[i].noPorts>>XM_LOG2_WORD_SZ)+sizeof(xmWord_t):(xmcPartitionTab[i].noPorts>>XM_LOG2_WORD_SZ))), PAGE_SIZE, "partition control tables"); 
    }
#ifdef CONFIG_MPU
    ArchMpuRsvMem(oFile);
#endif
    ArchLdrRsvMem(oFile);
#if defined(CONFIG_DEV_MEMBLOCK)||defined(CONFIG_DEV_MEMBLOCK_MODULE)
    // Memory Blocks
    RsvBlock(xmc.deviceTab.noMemBlocks*_KDEVICE_T_SIZEOF, ALIGNMENT, "memory block driver");
    RsvBlock(xmc.deviceTab.noMemBlocks*_STRUCT_MEMBLOCKDATA_SIZEOF, ALIGNMENT, "memory block driver");
#endif
#if defined(CONFIG_DEV_TTNOC)||defined(CONFIG_DEV_TTNOC_MODULE)
    RsvBlock(xmc.deviceTab.noTTnocSlots*_KDEVICE_T_SIZEOF, ALIGNMENT, "ttnoc driver");
#endif
    // Cyclic scheduler
    RsvBlock(xmc.hpv.noCpus*_STRUCT_SCHEDDATA_SIZEOF, ALIGNMENT, "scheduler data");

    // Console
    RsvBlock(xmc.noPartitions*_STRUCT_CONSOLE_SIZEOF, ALIGNMENT, "console object");

    // status    
    RsvBlock(xmc.noPartitions*_XMPARTITIONSTATUS_T_SIZEOF, ALIGNMENT, "status object");

    // trace
    RsvBlock(xmc.noPartitions*_STRUCT_LOGSTREAM_SIZEOF, ALIGNMENT, "trace object");

    // comm ports
    RsvBlock(xmc.noCommChannels*_UNION_CHANNEL_SIZEOF, ALIGNMENT, "commport object");
    RsvBlock(xmc.noCommPorts*_STRUCT_PORT_SIZEOF, ALIGNMENT, "commport object");
    for (i=0; i<xmc.noCommChannels; i++)
	switch(xmcCommChannelTab[i].type) {
	case XM_SAMPLING_CHANNEL:
	    RsvBlock(xmcCommChannelTab[i].s.maxLength, ALIGNMENT, "sampling commport object");
	    break;
	case XM_QUEUING_CHANNEL:
	    RsvBlock(xmcCommChannelTab[i].q.maxNoMsgs*_STRUCT_MSG_SIZEOF, ALIGNMENT, "queuing commport object");
	    for (j=0; j<xmcCommChannelTab[i].q.maxNoMsgs; j++)
		RsvBlock(xmcCommChannelTab[i].q.maxLength, ALIGNMENT, "queuing commport object");
	    
	    break;
	}
#if defined(CONFIG_DEV_UART)||defined(CONFIG_DEV_UART_MODULE)
#endif
    
    PrintBlocks(oFile);
}

#ifdef CONFIG_FP_SCHED
void GenerateFpSchedTab(FILE *oFile) {
    int e;

    fprintf(oFile, "const struct xmcFpSched xmcFpSchedTab[] = {\n");
    for (e=0; e<xmc.noFpEntries; e++) {
        fprintf(oFile, ADDNTAB(1, "[%d] = {.partitionId = %d, .vCpuId = %d, .priority = %d,},\n"), e, fpSchedTab[e].partitionId, fpSchedTab[e].vCpuId, fpSchedTab[e].priority);
    }
    fprintf(oFile, "};\n\n");

}
#endif


void GenerateVCpuTab(FILE *oFile){
    int part,vcpu,cpu;
    fprintf(oFile, "const struct xmcVCpu xmcVCpuTab[%d][%d] = {\n",xmc.noPartitions,xmc.hpv.noCpus);
    for (part=0; part<xmc.noPartitions; part++) {
        fprintf(oFile, "{\n");
        for (vcpu=0;vcpu<xmcPartitionTab[part].noVCpus && vcpu<xmc.hpv.noCpus;vcpu++){
            fprintf(oFile, ADDNTAB(1, "{.cpu = %d,},\n"), vCpuTab[part][vcpu].cpu);
        }
        for (cpu=vcpu;cpu<xmc.hpv.noCpus;cpu++){
            fprintf(oFile, ADDNTAB(1, "{.cpu = %d,},\n"),-1);
        }
        fprintf(oFile, "},\n");
    }
    fprintf(oFile, "};\n\n");
}

void GenerateCFile(FILE *oFile) {
    extern void GenerateIoPortTab(FILE *oFile);
    /* Header */
    fprintf(oFile, XMC_C_HEADER);
    fprintf(oFile, "extern char _xmcSize[];\n\n");
    fprintf(oFile, "extern char _dataSize[];\n\n");
    fprintf(oFile, "extern char _memObjTab[];\n\n");
    GenerateRegionTab(oFile);
    GeneratePhysMemAreaTab(oFile);
    GenerateCommChannelTab(oFile);
    GenerateCommPortTab(oFile);
    GenerateIpviTab(oFile);
#ifdef CONFIG_CYCLIC_SCHED
    GenerateCyclicSlots(oFile);
    GenerateCyclicPlans(oFile);
#endif
    GenerateIoPortTab(oFile);
    GenerateStringTab(oFile);
    GenerateSystemDevices(oFile);
    GeneratePartitionTab(oFile);
#ifdef CONFIG_FP_SCHED
    GenerateFpSchedTab(oFile);
#endif
    GenerateVCpuTab(oFile);
    GenerateXMC(oFile);
    GenerateRsvMem(oFile);
}
